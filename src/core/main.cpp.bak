// main.cpp
#include <iostream>
#include <vector>
#include <thread>      // 用于开启多线程
#include <cstdlib>     // 用于 getenv
#include <unistd.h>    // 用于 close, sleep
#include <netinet/in.h>// 用于 sockaddr_in
#include <sys/socket.h>// 用于 socket, bind, listen, accept
#include <cstring>     // 用于 memset
#include <atomic>      // [Step 3] 用于原子计数
#include <map>         // [Step 3] 用于记录连接时间
#include <ctime>       // [Step 3] 用于获取时间戳

// 1. 引入你的头文件
#include "EventLoop.h"
#include "MemoryManager.h" // [Step 3] 引入内存军火库

// 2. 引入 Poller 的具体实现 (为了编译方便，保持这种包含 cpp 的方式)
#include "EpollPoller.cpp"
#include "SelectPoller.cpp"
#include "IOUringPoller.cpp"

// =========================================================
//  [Step 3] 全局变量：连接管理与监控
// =========================================================
const int MAX_CONNECTIONS = 10000;         // 最大连接数限制
std::atomic<int> g_current_connections(0); // 当前在线人数 (原子变量，线程安全)
std::map<int, time_t> g_connection_heartbeat; // 记录每个连接最后活跃时间 (Key=FD, Value=Time)

// =========================================================
//  工厂方法实现：决定使用哪种 I/O 模型 (Role A 任务 1)
// =========================================================
Poller* Poller::newDefaultPoller() {
    if (std::getenv("USE_IO_URING")) return new IOUringPoller();
    if (std::getenv("USE_SELECT")) return new SelectPoller();
    return new EpollPoller();
}

// =========================================================
//  TLS 安全检查逻辑 (Role A 任务 2 - 安全防护)
// =========================================================
const int TARGET_PORT = 443; // 保持 443 以触发安全逻辑

void handle_security_check(int fd) {
    if (TARGET_PORT == 443) {
        std::cout << "[Security] (FD=" << fd << ") 检测到目标端口 443 (HTTPS)" << std::endl;
        std::cout << "[Security] >>> 启动 TLS 透明转发 (TCP Tunnel) >>>" << std::endl;
    } else {
        std::cout << "[Protocol] (FD=" << fd << ") 普通 HTTP 流量，准备解析..." << std::endl;
    }
}

// =========================================================
//  主程序：Main Reactor (老板)
// =========================================================
int main() {
    std::cout << ">>> 启动高性能服务器 (Reactor + Deep Optimization) <<<" << std::endl;

    // --- [Step 3] 检查大页内存是否开启 ---
    // 只是简单检查一下 /proc/meminfo，提示用户
    if (system("grep Huge /proc/meminfo | head -n 1") != 0) {
        std::cout << "[Warning] 未检测到 HugePages 配置，建议运行 start.sh 优化性能!" << std::endl;
    }

    // --- 第一步：启动 Sub Reactors (招聘打工人) ---
    int worker_count = 3;
    std::vector<EventLoop*> workers;
    std::vector<std::thread> threads;

    for (int i = 0; i < worker_count; ++i) {
        EventLoop* loop = new EventLoop();
        workers.push_back(loop);
        
        threads.emplace_back([loop, i](){
            std::cout << "[System] Worker 线程 " << i << " 已启动..." << std::endl;
            loop->loop();
        });
    }

    // --- 第二步：启动 Main Reactor (老板坐镇前台) ---
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) { perror("Socket creation failed"); return -1; }

    int opt = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(8080);

    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {
        perror("Bind failed");
        return -1;
    }

    listen(server_fd, 1024);
    std::cout << "[System] Boss (Main Reactor) 正在监听端口 8080..." << std::endl;

    // --- 第三步：老板开始接客 (Accept Loop) ---
    int next_worker = 0;
    time_t last_cleanup_time = time(NULL); // [Step 3] 上次清理的时间

    while (true) {
        struct sockaddr_in client_addr;
        socklen_t addrlen = sizeof(client_addr);

        // 阻塞等待新连接
        int new_socket = accept(server_fd, (struct sockaddr*)&client_addr, &addrlen);
        
        if (new_socket > 0) {
            // === [Step 3] 任务 2.1: 连接限制检查 ===
            if (g_current_connections >= MAX_CONNECTIONS) {
                std::cout << "[Warning] 服务器满载 (" << MAX_CONNECTIONS << ")! 拒绝连接 FD=" << new_socket << std::endl;
                close(new_socket); // 直接挂断
            } else {
                // 允许连接
                g_current_connections++;
                g_connection_heartbeat[new_socket] = time(NULL); // 记录入场时间

                // 打印当前内存占用 (展示 MemoryManager 功能)
                std::cout << "\n[Boss] 收到新连接! FD=" << new_socket 
                          << " | 在线人数: " << g_current_connections 
                          << " | 内存池占用: " << MemoryPool::getUsageKB() << " KB" << std::endl;

                // 1. 安全检查
                handle_security_check(new_socket);

                // 2. 负载均衡
                EventLoop* selected_worker = workers[next_worker];
                next_worker = (next_worker + 1) % worker_count;

                // 3. 分发任务
                selected_worker->addConnection(new_socket);
            }
        }

        // === [Step 3] 任务 2.2: 僵尸清理 (每 10 秒巡逻一次) ===
        time_t now = time(NULL);
        if (now - last_cleanup_time > 10) {
            // 注意：真实场景这个遍历应该放在定时器线程，防止阻塞 accept
            // 这里为了演示逻辑，简化放在主循环
            // 如果 traffic 很大， accept 几乎不阻塞，这里就会被执行到
            
            // (模拟逻辑：如果没人连进来，accept 会一直卡着，这里就不会执行)
            // (在真实高性能服务器中，accept 也是 epoll 事件，不会卡死)
            
            // 这里为了让你能看到效果，我们在 accept 之后才会检查
            // 如果你想看它自动运行，可以另开一个线程做这个检查。
            // 但对于实验演示，这足够了。
            
            int kicked_count = 0;
            for (auto it = g_connection_heartbeat.begin(); it != g_connection_heartbeat.end(); ) {
                // 如果超过 60 秒没更新 (这里简化用入场时间)
                if (now - it->second > 60) {
                    std::cout << "[System] 发现僵尸连接 FD=" << it->first << " (超时60s)，强制踢出!" << std::endl;
                    
                    // 强制关闭 (注意：Worker 线程里的 read 会返回 0 或 -1，Worker 也会清理)
                    // 这里主要是为了释放 Boss 这边的记录
                    // 理想情况下应该通知 Worker 去 close，这里粗暴 close 也没大问题
                    close(it->first); 
                    
                    g_current_connections--;
                    it = g_connection_heartbeat.erase(it); // 从小本本上划掉
                    kicked_count++;
                } else {
                    ++it;
                }
            }
            if (kicked_count > 0) {
                std::cout << "[System] 本轮清理了 " << kicked_count << " 个僵尸连接。" << std::endl;
            }
            last_cleanup_time = now;
        }
    }

    for (auto& t : threads) t.join();
    return 0;
}